## 索引
* [目的](#目的) 
* [匯入相關函式庫](#匯入相關函式庫)
* [動態規劃演算法](#動態規劃演算法)
* [爬山演算法](#爬山演算法)
* [模擬退火演算法](#模擬退火演算法)
* [結語](#結語)
## 目的
#### 背包問題是期望最後的背包價值能在背包容量可負荷的情形下擁有最大之價值，此問題與旅遊行程安排的問題類似，旅遊問題是希望在能遊玩的期間(背包容量)內玩到最盡興的景點組合(總價最高之物品組合)。解決此複雜問題可透過:
* [動態規劃演算法](#動態規劃演算法)
* [爬山演算法](#爬山演算法)
* [模擬退火演算法](#模擬退火演算法)
#### 3種演算法來解決，動態規劃法的精隨是表格，也就是二維陣列，透過每一次迴圈中可選的物品組合搭配所有子背包來決定子背包現在應放之物品組合以達到目前子背包的最大價值，整個二維陣列的column是所有子背包的容量，row是可選之物品組合，比如第一列是筆電、第二列是水壺，假設現在迴圈來到第二列，則現在可選之物品有筆電及水壺兩項。爬山演算法是基於每一次產生不同隨機解(隨機拿取的物品組合)，條件1是比較物品組合是否重量小於背包可容納隻重量，若是則進入條件2，條件2是是否現在的物品組合之總價值是否大於前面所有迭代之最高價值，若是則將此物品組合作為目前最佳解，迭代此過程至設定的最大迭代次數。模擬退火演算法與爬山演算法之理論和實作皆類似，都是透過每一次迭代找到最佳解，差別在於模擬退火演算法擁有機率獲得較差解，可防止迭代未完成就找到解，而這個解也不一定是全局最佳解，因此模擬退火演算法是爬山演算法的改良版本。
## 匯入相關函式庫 
###### 1. matplotlib.pyplot:繪製收斂圖所需
###### 2. random:用來產生初始隨機物品組合
###### 3. math:模擬退火演算法需要指數函數
## 匯入物品重量、價值，背包空間及正確的物品組合 
#### 將記錄物體重量、價值，背包容量以及正解之檔案匯入並存到變數供後續演算法使用。
## 動態規劃演算法
#### 動態規劃演算法是透過將背包分割成多個子背包，並在現有能拿取的物品中，配合目前的背包容量，選擇最高價值的物品組合。透過建立二維陣列來表示此演算法，以列為可拿物品，搜尋該列以及該列以上的列在目前的背包容量可裝的最高價值之物品組合。先初始化陣列全為0，列為物品，欄為各個子背包容量，假設table[3][6]為要更新的子背包，查看目前背包的容量是否裝得下現在可拿的物品，若裝得下則判斷拿了新物品的總價值和沒有拿物品的總價值的高低，高的值用來更新此子背包。
## 爬山演算法
#### 爬山演算法是透過一定次數的迭代找出峰值(最優解)的行為，用在背包問題就是找出物品價值最高的物品組合是甚麼，但這個演算法可能會無法迭代到全局最優解，因為此演算法不接受較差解，所以可能找到目前的最優解後，遇到往下的斜坡到山谷(相對較差解)，就無法往前迭代了，可能迭代到後面就能找到更優解。實作方式: 每次迭代產生隨機物品組合，當此隨機物品組合的總價值大於上一次迭代的總價值則更新最優解的價值，直到找到符合輸入的正確答案後跳出迭代。
## 模擬退火演算法
#### 模擬退火演算法與爬山演算法類似，都是透過迭代找到全局最優解，不一樣的是模擬退火演算法是透過每次迭代的降溫，將溫度代入價值差的分母計算成為自然函數的指數，當指數愈大，當次迭代有機會接受較差解並繼續迭代，這是為了避免爬山演算法只能找到局部最優解的特性，但是就是因為模擬退火演算法有機率可以接受較差解，因此他可能迭代到最後只儲存局部最優解，所以需要透過比對輸入的正確答案的物品組合的總價值，若比對成功則直接跳出迴圈並輸出，或是比較每次迭代的總價值，並將值存入另一個變數，若該次迭代的總價值沒有比上一次來得高，就不更新此變數，若比較高，則更新此變數。
## 結語
#### 
